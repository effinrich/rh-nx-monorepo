# 5. ORM

Date: 2022-09-27

## Status

Accepted

## Context

I'd like to add an ORM to interface between our business logic and database.

ORMs help with the following
* Security - prevent SQL injection through parameterized queries
* Transaction Management - ability to group multiple calls in a single transaction
* Caching - 1st level caching (in memory) and 2nd level caching (in memory/external cache) to protect the DB
* Developer Experience - allows developers to interact with the DB through POJOs

The ORM pattern has become widely adopted in Java with a specification called [JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation).

[Hibernate](https://hibernate.org) is an implementation of the JPA specification.

## Decision

We will use [Spring Data](https://spring.io/projects/spring-data): a wrapper around JPA with Hibernate as the implementation. The library has support for Postgres's driver--which we'll use to interact with CockroachDB.

## Consequences

1. The addition of Spring Data requires additional ramp up time to new developers. Spring has a great overview here: [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/). Troubleshooting issues in library this big can lead to a lot of headaches. Hopefully we'll be able to mitigate frustration through team help and documentation.

2. When opting into any library, developers lose flexibility. Spring Data has the ability to opt-out of its [magic repository system](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation), by writing [custom repositories](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.custom-implementations). This gives developers the ability to turn all of the Hibernate knobs they need.