/* tslint:disable */
/* eslint-disable */
/**
 * Company API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.5-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  timestamp: string
  /**
   *
   * @type {number}
   * @memberof ApiError
   */
  status: number
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  error: string
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  path: string
}
/**
 *
 * @export
 * @interface ApiFieldError
 */
export interface ApiFieldError {
  /**
   *
   * @type {string}
   * @memberof ApiFieldError
   */
  timestamp: string
  /**
   *
   * @type {number}
   * @memberof ApiFieldError
   */
  status: number
  /**
   *
   * @type {string}
   * @memberof ApiFieldError
   */
  error: string
  /**
   *
   * @type {string}
   * @memberof ApiFieldError
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ApiFieldError
   */
  path: string
  /**
   *
   * @type {Array<FieldErrorDetails>}
   * @memberof ApiFieldError
   */
  errors: Array<FieldErrorDetails>
}
/**
 *
 * @export
 * @interface CollectionModelPersonSummary
 */
export interface CollectionModelPersonSummary {
  /**
   *
   * @type {Array<Link>}
   * @memberof CollectionModelPersonSummary
   */
  links?: Array<Link>
  /**
   *
   * @type {Array<PersonSummary>}
   * @memberof CollectionModelPersonSummary
   */
  content?: Array<PersonSummary>
}
/**
 *
 * @export
 * @interface CollectionModelRole
 */
export interface CollectionModelRole {
  /**
   *
   * @type {Array<Link>}
   * @memberof CollectionModelRole
   */
  links?: Array<Link>
  /**
   *
   * @type {Array<Role>}
   * @memberof CollectionModelRole
   */
  content?: Array<Role>
}
/**
 *
 * @export
 * @interface CompanyCommand
 */
export interface CompanyCommand {
  /**
   *
   * @type {number}
   * @memberof CompanyCommand
   */
  number?: number
  /**
   *
   * @type {string}
   * @memberof CompanyCommand
   */
  legalName?: string
  /**
   *
   * @type {string}
   * @memberof CompanyCommand
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CompanyCommand
   */
  description?: string
}
/**
 *
 * @export
 * @interface CompanySummary
 */
export interface CompanySummary {
  dashboardHref?: string
  status: string
  stage: any
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  id: string
  /**
   *
   * @type {number}
   * @memberof CompanySummary
   */
  number?: number
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  legalName?: string
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  description?: string
  /**
   *
   * @type {Array<PersonSummary>}
   * @memberof CompanySummary
   */
  members?: Array<PersonSummary>
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  created?: string
  /**
   *
   * @type {string}
   * @memberof CompanySummary
   */
  lastModified?: string
  /**
   *
   * @type {Array<Link>}
   * @memberof CompanySummary
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface CreatePersonCommand
 */
export interface CreatePersonCommand {
  /**
   *
   * @type {string}
   * @memberof CreatePersonCommand
   */
  givenName?: string
  /**
   *
   * @type {string}
   * @memberof CreatePersonCommand
   */
  familyName?: string
  /**
   *
   * @type {string}
   * @memberof CreatePersonCommand
   */
  email: string
}
/**
 *
 * @export
 * @interface EntityModelMapObjectObject
 */
export interface EntityModelMapObjectObject {
  /**
   *
   * @type {Array<Link>}
   * @memberof EntityModelMapObjectObject
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface EntityModelMapStringObject
 */
export interface EntityModelMapStringObject {
  /**
   *
   * @type {Array<Link>}
   * @memberof EntityModelMapStringObject
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface FieldErrorDetails
 */
export interface FieldErrorDetails {
  /**
   *
   * @type {string}
   * @memberof FieldErrorDetails
   */
  name: string
  /**
   *
   * @type {object}
   * @memberof FieldErrorDetails
   */
  rejectedValue: object
  /**
   *
   * @type {string}
   * @memberof FieldErrorDetails
   */
  description: string
}
/**
 *
 * @export
 * @interface InfraRequestCommand
 */
export interface InfraRequestCommand {
  /**
   *
   * @type {string}
   * @memberof InfraRequestCommand
   */
  status?: InfraRequestCommandStatusEnum
  /**
   *
   * @type {string}
   * @memberof InfraRequestCommand
   */
  jiraIssueId?: string
}

export const InfraRequestCommandStatusEnum = {
  AwaitingSubmission: 'AWAITING_SUBMISSION',
  Pending: 'PENDING',
  Done: 'DONE',
  InProgress: 'IN_PROGRESS'
} as const

export type InfraRequestCommandStatusEnum =
  typeof InfraRequestCommandStatusEnum[keyof typeof InfraRequestCommandStatusEnum]

/**
 *
 * @export
 * @interface InfraRequestSummary
 */
export interface InfraRequestSummary {
  /**
   *
   * @type {string}
   * @memberof InfraRequestSummary
   */
  jiraIssueId?: string
  /**
   *
   * @type {SerializableEnum}
   * @memberof InfraRequestSummary
   */
  status: SerializableEnum
  /**
   *
   * @type {Array<RequestFormSummary>}
   * @memberof InfraRequestSummary
   */
  forms?: Array<RequestFormSummary>
  /**
   *
   * @type {Array<Link>}
   * @memberof InfraRequestSummary
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  rel?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  hreflang?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  media?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  deprecation?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  profile?: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  name?: string
}
/**
 *
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
  /**
   *
   * @type {number}
   * @memberof PageMetadata
   */
  size?: number
  /**
   *
   * @type {number}
   * @memberof PageMetadata
   */
  totalElements?: number
  /**
   *
   * @type {number}
   * @memberof PageMetadata
   */
  totalPages?: number
  /**
   *
   * @type {number}
   * @memberof PageMetadata
   */
  number?: number
}
/**
 *
 * @export
 * @interface PagedModelCompanySummary
 */
export interface PagedModelCompanySummary {
  /**
   *
   * @type {Array<Link>}
   * @memberof PagedModelCompanySummary
   */
  links?: Array<Link>
  /**
   *
   * @type {Array<CompanySummary>}
   * @memberof PagedModelCompanySummary
   */
  content?: Array<CompanySummary>
  /**
   *
   * @type {PageMetadata}
   * @memberof PagedModelCompanySummary
   */
  page?: PageMetadata
}
/**
 *
 * @export
 * @interface PagedModelPersonRequestSummary
 */
export interface PagedModelPersonRequestSummary {
  /**
   *
   * @type {Array<Link>}
   * @memberof PagedModelPersonRequestSummary
   */
  links?: Array<Link>
  /**
   *
   * @type {Array<PersonRequestSummary>}
   * @memberof PagedModelPersonRequestSummary
   */
  content?: Array<PersonRequestSummary>
  /**
   *
   * @type {PageMetadata}
   * @memberof PagedModelPersonRequestSummary
   */
  page?: PageMetadata
}
/**
 *
 * @export
 * @interface PagedModelPersonSummary
 */
export interface PagedModelPersonSummary {
  /**
   *
   * @type {Array<Link>}
   * @memberof PagedModelPersonSummary
   */
  links?: Array<Link>
  /**
   *
   * @type {Array<PersonSummary>}
   * @memberof PagedModelPersonSummary
   */
  content?: Array<PersonSummary>
  /**
   *
   * @type {PageMetadata}
   * @memberof PagedModelPersonSummary
   */
  page?: PageMetadata
}
/**
 *
 * @export
 * @interface PersonCommand
 */
export interface PersonCommand {
  /**
   *
   * @type {string}
   * @memberof PersonCommand
   */
  givenName?: string
  /**
   *
   * @type {string}
   * @memberof PersonCommand
   */
  familyName?: string
}
/**
 *
 * @export
 * @interface PersonRequestCommand
 */
export interface PersonRequestCommand {
  /**
   *
   * @type {string}
   * @memberof PersonRequestCommand
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof PersonRequestCommand
   */
  familyName?: string
  /**
   *
   * @type {string}
   * @memberof PersonRequestCommand
   */
  givenName?: string
  /**
   *
   * @type {Array<string>}
   * @memberof PersonRequestCommand
   */
  companies?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PersonRequestCommand
   */
  roles?: Array<PersonRequestCommandRolesEnum>
}

export const PersonRequestCommandRolesEnum = {
  RhAdmin: 'ROLE_RH_ADMIN',
  SuperAdmin: 'ROLE_SUPER_ADMIN',
  RhUser: 'ROLE_RH_USER',
  OpCoUser: 'ROLE_OP_CO_USER',
  OpCoContractor: 'ROLE_OP_CO_CONTRACTOR'
} as const

export type PersonRequestCommandRolesEnum =
  typeof PersonRequestCommandRolesEnum[keyof typeof PersonRequestCommandRolesEnum]

/**
 *
 * @export
 * @interface PersonRequestSummary
 */
export interface PersonRequestSummary {
  /**
   *
   * @type {string}
   * @memberof PersonRequestSummary
   */
  givenName?: string
  /**
   *
   * @type {string}
   * @memberof PersonRequestSummary
   */
  familyName?: string
  /**
   *
   * @type {string}
   * @memberof PersonRequestSummary
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof PersonRequestSummary
   */
  jiraIssueId?: string
  /**
   *
   * @type {Array<CompanySummary>}
   * @memberof PersonRequestSummary
   */
  companies?: Array<CompanySummary>
  /**
   *
   * @type {Array<Role>}
   * @memberof PersonRequestSummary
   */
  roles?: Array<Role>
  /**
   *
   * @type {SerializableEnum}
   * @memberof PersonRequestSummary
   */
  status?: SerializableEnum
  /**
   *
   * @type {Array<Link>}
   * @memberof PersonRequestSummary
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface PersonSummary
 */
export interface PersonSummary {
  /**
   *
   * @type {string}
   * @memberof PersonSummary
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof PersonSummary
   */
  givenName?: string
  /**
   *
   * @type {string}
   * @memberof PersonSummary
   */
  familyName?: string
  /**
   *
   * @type {Array<Role>}
   * @memberof PersonSummary
   */
  roles?: Array<Role>
  /**
   *
   * @type {Array<CompanySummary>}
   * @memberof PersonSummary
   */
  memberOf?: Array<CompanySummary>
  /**
   *
   * @type {string}
   * @memberof PersonSummary
   */
  created?: string
  /**
   *
   * @type {string}
   * @memberof PersonSummary
   */
  lastModified?: string
  /**
   *
   * @type {Array<Link>}
   * @memberof PersonSummary
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface RequestFormCommand
 */
export interface RequestFormCommand {
  /**
   *
   * @type {string}
   * @memberof RequestFormCommand
   */
  status?: RequestFormCommandStatusEnum
  /**
   *
   * @type {object}
   * @memberof RequestFormCommand
   */
  form?: object
}

export const RequestFormCommandStatusEnum = {
  NotStarted: 'NOT_STARTED',
  Draft: 'DRAFT',
  Completed: 'COMPLETED'
} as const

export type RequestFormCommandStatusEnum =
  typeof RequestFormCommandStatusEnum[keyof typeof RequestFormCommandStatusEnum]

/**
 *
 * @export
 * @interface RequestFormSummary
 */
export interface RequestFormSummary {
  /**
   *
   * @type {SerializableEnum}
   * @memberof RequestFormSummary
   */
  status: SerializableEnum
  /**
   *
   * @type {SerializableEnum}
   * @memberof RequestFormSummary
   */
  type?: SerializableEnum
  /**
   *
   * @type {object}
   * @memberof RequestFormSummary
   */
  form?: object
  /**
   *
   * @type {Array<Link>}
   * @memberof RequestFormSummary
   */
  links?: Array<Link>
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {string}
   * @memberof Role
   */
  authority: RoleAuthorityEnum
  /**
   *
   * @type {string}
   * @memberof Role
   */
  displayName: string
}

export const RoleAuthorityEnum = {
  RhAdmin: 'ROLE_RH_ADMIN',
  SuperAdmin: 'ROLE_SUPER_ADMIN',
  RhUser: 'ROLE_RH_USER',
  OpCoUser: 'ROLE_OP_CO_USER',
  OpCoContractor: 'ROLE_OP_CO_CONTRACTOR'
} as const

export type RoleAuthorityEnum =
  typeof RoleAuthorityEnum[keyof typeof RoleAuthorityEnum]

/**
 *
 * @export
 * @interface SerializableEnum
 */
export interface SerializableEnum {
  /**
   *
   * @type {string}
   * @memberof SerializableEnum
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof SerializableEnum
   */
  displayName?: string
}
/**
 *
 * @export
 * @interface UserInfoSummary
 */
export interface UserInfoSummary {
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  givenName?: string
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  familyName?: string
  /**
   *
   * @type {Array<Role>}
   * @memberof UserInfoSummary
   */
  roles?: Array<Role>
  /**
   *
   * @type {Array<CompanySummary>}
   * @memberof UserInfoSummary
   */
  memberOf?: Array<CompanySummary>
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  created?: string
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  lastModified?: string
  /**
   *
   * @type {string}
   * @memberof UserInfoSummary
   */
  picture?: string
  /**
   *
   * @type {Array<Link>}
   * @memberof UserInfoSummary
   */
  links?: Array<Link>
}

/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPerson: async (
      companyId: string,
      email: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('addPerson', 'companyId', companyId)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('addPerson', 'email', email)
      const localVarPath = `/company/{companyId}/member/{email}`
        .replace(`{${'companyId'}}`, encodeURIComponent(String(companyId)))
        .replace(`{${'email'}}`, encodeURIComponent(String(email)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create1: async (
      companyCommand: CompanyCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyCommand' is not null or undefined
      assertParamExists('create1', 'companyCommand', companyCommand)
      const localVarPath = `/company`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        companyCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete1: async (
      companyId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('delete1', 'companyId', companyId)
      const localVarPath = `/company/{companyId}`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('get', 'companyId', companyId)
      const localVarPath = `/company/{companyId}`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (expand) {
        localVarQueryParameter.expand = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      const headersFromBaseOptions = baseOptions?.headers
        ? baseOptions.headers
        : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll2: async (
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/company`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (expand) {
        localVarQueryParameter['expand'] = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMembers: async (
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('getMembers', 'companyId', companyId)
      const localVarPath = `/company/{companyId}/members`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (expand) {
        localVarQueryParameter['expand'] = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Remove a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePerson: async (
      companyId: string,
      email: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('removePerson', 'companyId', companyId)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('removePerson', 'email', email)
      const localVarPath = `/company/{companyId}/member/{email}`
        .replace(`{${'companyId'}}`, encodeURIComponent(String(companyId)))
        .replace(`{${'email'}}`, encodeURIComponent(String(email)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update
     * @param {string} companyId
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update1: async (
      companyId: string,
      companyCommand: CompanyCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('update1', 'companyId', companyId)
      // verify required parameter 'companyCommand' is not null or undefined
      assertParamExists('update1', 'companyCommand', companyCommand)
      const localVarPath = `/company/{companyId}`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        companyCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Add a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPerson(
      companyId: string,
      email: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapObjectObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPerson(
        companyId,
        email,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Create
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create1(
      companyCommand: CompanyCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanySummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create1(
        companyCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delete1(
      companyId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(
        companyId,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanySummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(
        companyId,
        expand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll2(
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PagedModelCompanySummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll2(
        page,
        size,
        sort,
        expand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMembers(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CollectionModelPersonSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(
        companyId,
        expand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Remove a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePerson(
      companyId: string,
      email: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapObjectObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePerson(
        companyId,
        email,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Update
     * @param {string} companyId
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update1(
      companyId: string,
      companyCommand: CompanyCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanySummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update1(
        companyId,
        companyCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanyApiFp(configuration)
  return {
    /**
     *
     * @summary Add a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPerson(
      companyId: string,
      email: string,
      options?: any
    ): AxiosPromise<EntityModelMapObjectObject> {
      return localVarFp
        .addPerson(companyId, email, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create1(
      companyCommand: CompanyCommand,
      options?: any
    ): AxiosPromise<CompanySummary> {
      return localVarFp
        .create1(companyCommand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete1(companyId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .delete1(companyId, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<CompanySummary> {
      return localVarFp
        .get(companyId, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll2(
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<PagedModelCompanySummary> {
      return localVarFp
        .getAll2(page, size, sort, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMembers(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<CollectionModelPersonSummary> {
      return localVarFp
        .getMembers(companyId, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Remove a user
     * @param {string} companyId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePerson(
      companyId: string,
      email: string,
      options?: any
    ): AxiosPromise<EntityModelMapObjectObject> {
      return localVarFp
        .removePerson(companyId, email, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Update
     * @param {string} companyId
     * @param {CompanyCommand} companyCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update1(
      companyId: string,
      companyCommand: CompanyCommand,
      options?: any
    ): AxiosPromise<CompanySummary> {
      return localVarFp
        .update1(companyId, companyCommand, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
  /**
   *
   * @summary Add a user
   * @param {string} companyId
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public addPerson(
    companyId: string,
    email: string,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .addPerson(companyId, email, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create
   * @param {CompanyCommand} companyCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public create1(companyCommand: CompanyCommand, options?: AxiosRequestConfig) {
    return CompanyApiFp(this.configuration)
      .create1(companyCommand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public delete1(companyId: string, options?: AxiosRequestConfig) {
    return CompanyApiFp(this.configuration)
      .delete1(companyId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public get(
    companyId: string,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .get(companyId, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public getAll2(
    page?: number,
    size?: number,
    sort?: Array<string>,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .getAll2(page, size, sort, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public getMembers(
    companyId: string,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .getMembers(companyId, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove a user
   * @param {string} companyId
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public removePerson(
    companyId: string,
    email: string,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .removePerson(companyId, email, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update
   * @param {string} companyId
   * @param {CompanyCommand} companyCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyApi
   */
  public update1(
    companyId: string,
    companyCommand: CompanyCommand,
    options?: AxiosRequestConfig
  ) {
    return CompanyApiFp(this.configuration)
      .update1(companyId, companyCommand, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * InfrastructureRequestApi - axios parameter creator
 * @export
 */
export const InfrastructureRequestApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfrastructure: async (
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('getInfrastructure', 'companyId', companyId)
      const localVarPath = `/infra-request/{companyId}`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (expand) {
        localVarQueryParameter['expand'] = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitRequest: async (
      companyId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('submitRequest', 'companyId', companyId)
      const localVarPath = `/infra-request/{companyId}/submit`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE'} type
     * @param {RequestFormCommand} requestFormCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateForm: async (
      companyId: string,
      type: 'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE',
      requestFormCommand: RequestFormCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('updateForm', 'companyId', companyId)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('updateForm', 'type', type)
      // verify required parameter 'requestFormCommand' is not null or undefined
      assertParamExists('updateForm', 'requestFormCommand', requestFormCommand)
      const localVarPath = `/infra-request/{companyId}/form/{type}`
        .replace(`{${'companyId'}}`, encodeURIComponent(String(companyId)))
        .replace(`{${'type'}}`, encodeURIComponent(String(type)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestFormCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} companyId
     * @param {InfraRequestCommand} infraRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfrastructure: async (
      companyId: string,
      infraRequestCommand: InfraRequestCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companyId' is not null or undefined
      assertParamExists('updateInfrastructure', 'companyId', companyId)
      // verify required parameter 'infraRequestCommand' is not null or undefined
      assertParamExists(
        'updateInfrastructure',
        'infraRequestCommand',
        infraRequestCommand
      )
      const localVarPath = `/infra-request/{companyId}`.replace(
        `{${'companyId'}}`,
        encodeURIComponent(String(companyId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        infraRequestCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * InfrastructureRequestApi - functional programming interface
 * @export
 */
export const InfrastructureRequestApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    InfrastructureRequestApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfrastructure(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InfraRequestSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInfrastructure(
          companyId,
          expand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitRequest(
      companyId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InfraRequestSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitRequest(
        companyId,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE'} type
     * @param {RequestFormCommand} requestFormCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateForm(
      companyId: string,
      type: 'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE',
      requestFormCommand: RequestFormCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RequestFormSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(
        companyId,
        type,
        requestFormCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} companyId
     * @param {InfraRequestCommand} infraRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInfrastructure(
      companyId: string,
      infraRequestCommand: InfraRequestCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InfraRequestSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateInfrastructure(
          companyId,
          infraRequestCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * InfrastructureRequestApi - factory interface
 * @export
 */
export const InfrastructureRequestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InfrastructureRequestApiFp(configuration)
  return {
    /**
     *
     * @param {string} companyId
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfrastructure(
      companyId: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<InfraRequestSummary> {
      return localVarFp
        .getInfrastructure(companyId, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitRequest(
      companyId: string,
      options?: any
    ): AxiosPromise<InfraRequestSummary> {
      return localVarFp
        .submitRequest(companyId, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE'} type
     * @param {RequestFormCommand} requestFormCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateForm(
      companyId: string,
      type: 'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE',
      requestFormCommand: RequestFormCommand,
      options?: any
    ): AxiosPromise<RequestFormSummary> {
      return localVarFp
        .updateForm(companyId, type, requestFormCommand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} companyId
     * @param {InfraRequestCommand} infraRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfrastructure(
      companyId: string,
      infraRequestCommand: InfraRequestCommand,
      options?: any
    ): AxiosPromise<InfraRequestSummary> {
      return localVarFp
        .updateInfrastructure(companyId, infraRequestCommand, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * InfrastructureRequestApi - object-oriented interface
 * @export
 * @class InfrastructureRequestApi
 * @extends {BaseAPI}
 */
export class InfrastructureRequestApi extends BaseAPI {
  /**
   *
   * @param {string} companyId
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfrastructureRequestApi
   */
  public getInfrastructure(
    companyId: string,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return InfrastructureRequestApiFp(this.configuration)
      .getInfrastructure(companyId, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfrastructureRequestApi
   */
  public submitRequest(companyId: string, options?: AxiosRequestConfig) {
    return InfrastructureRequestApiFp(this.configuration)
      .submitRequest(companyId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE'} type
   * @param {RequestFormCommand} requestFormCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfrastructureRequestApi
   */
  public updateForm(
    companyId: string,
    type: 'TECH_STACK' | 'PRIVACY_QUESTIONNAIRE',
    requestFormCommand: RequestFormCommand,
    options?: AxiosRequestConfig
  ) {
    return InfrastructureRequestApiFp(this.configuration)
      .updateForm(companyId, type, requestFormCommand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} companyId
   * @param {InfraRequestCommand} infraRequestCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfrastructureRequestApi
   */
  public updateInfrastructure(
    companyId: string,
    infraRequestCommand: InfraRequestCommand,
    options?: AxiosRequestConfig
  ) {
    return InfrastructureRequestApiFp(this.configuration)
      .updateInfrastructure(companyId, infraRequestCommand, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      email: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('_delete', 'email', email)
      const localVarPath = `/person/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Add a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRole: async (
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('addRole', 'email', email)
      // verify required parameter 'authority' is not null or undefined
      assertParamExists('addRole', 'authority', authority)
      const localVarPath = `/person/{email}/role/{authority}`
        .replace(`{${'email'}}`, encodeURIComponent(String(email)))
        .replace(`{${'authority'}}`, encodeURIComponent(String(authority)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {CreatePersonCommand} createPersonCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      createPersonCommand: CreatePersonCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPersonCommand' is not null or undefined
      assertParamExists('create', 'createPersonCommand', createPersonCommand)
      const localVarPath = `/person`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPersonCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1: async (
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/person`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      if (expand) {
        localVarQueryParameter['expand'] = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} email
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOne: async (
      email: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('getOne', 'email', email)
      const localVarPath = `/person/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (expand) {
        localVarQueryParameter['expand'] = expand
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Remove a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRole: async (
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('removeRole', 'email', email)
      // verify required parameter 'authority' is not null or undefined
      assertParamExists('removeRole', 'authority', authority)
      const localVarPath = `/person/{email}/role/{authority}`
        .replace(`{${'email'}}`, encodeURIComponent(String(email)))
        .replace(`{${'authority'}}`, encodeURIComponent(String(authority)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create or update
     * @param {string} email
     * @param {PersonCommand} personCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      email: string,
      personCommand: PersonCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('update', 'email', email)
      // verify required parameter 'personCommand' is not null or undefined
      assertParamExists('update', 'personCommand', personCommand)
      const localVarPath = `/person/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        personCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      email: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        email,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRole(
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapObjectObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addRole(
        email,
        authority,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {CreatePersonCommand} createPersonCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      createPersonCommand: CreatePersonCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        createPersonCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PagedModelPersonSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(
        page,
        size,
        sort,
        expand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} email
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOne(
      email: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOne(
        email,
        expand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Remove a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeRole(
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapObjectObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeRole(
        email,
        authority,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Create or update
     * @param {string} email
     * @param {PersonCommand} personCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      email: string,
      personCommand: PersonCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        email,
        personCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PersonApiFp(configuration)
  return {
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(email: string, options?: any): AxiosPromise<void> {
      return localVarFp
        ._delete(email, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRole(
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options?: any
    ): AxiosPromise<EntityModelMapObjectObject> {
      return localVarFp
        .addRole(email, authority, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {CreatePersonCommand} createPersonCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      createPersonCommand: CreatePersonCommand,
      options?: any
    ): AxiosPromise<PersonSummary> {
      return localVarFp
        .create(createPersonCommand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<PagedModelPersonSummary> {
      return localVarFp
        .getAll1(page, size, sort, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} email
     * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOne(
      email: string,
      expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
      options?: any
    ): AxiosPromise<PersonSummary> {
      return localVarFp
        .getOne(email, expand, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Remove a role
     * @param {string} email
     * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRole(
      email: string,
      authority:
        | 'ROLE_RH_ADMIN'
        | 'ROLE_RH_USER'
        | 'ROLE_OP_CO_USER'
        | 'ROLE_OP_CO_CONTRACTOR',
      options?: any
    ): AxiosPromise<EntityModelMapObjectObject> {
      return localVarFp
        .removeRole(email, authority, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create or update
     * @param {string} email
     * @param {PersonCommand} personCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      email: string,
      personCommand: PersonCommand,
      options?: any
    ): AxiosPromise<PersonSummary> {
      return localVarFp
        .update(email, personCommand, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
  /**
   *
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public _delete(email: string, options?: AxiosRequestConfig) {
    return PersonApiFp(this.configuration)
      ._delete(email, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add a role
   * @param {string} email
   * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public addRole(
    email: string,
    authority:
      | 'ROLE_RH_ADMIN'
      | 'ROLE_RH_USER'
      | 'ROLE_OP_CO_USER'
      | 'ROLE_OP_CO_CONTRACTOR',
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .addRole(email, authority, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {CreatePersonCommand} createPersonCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public create(
    createPersonCommand: CreatePersonCommand,
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .create(createPersonCommand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public getAll1(
    page?: number,
    size?: number,
    sort?: Array<string>,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .getAll1(page, size, sort, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} email
   * @param {Array<'forms' | 'members' | 'memberOf' | 'roles'>} [expand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public getOne(
    email: string,
    expand?: Array<'forms' | 'members' | 'memberOf' | 'roles'>,
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .getOne(email, expand, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove a role
   * @param {string} email
   * @param {'ROLE_RH_ADMIN' | 'ROLE_RH_USER' | 'ROLE_OP_CO_USER' | 'ROLE_OP_CO_CONTRACTOR'} authority
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public removeRole(
    email: string,
    authority:
      | 'ROLE_RH_ADMIN'
      | 'ROLE_RH_USER'
      | 'ROLE_OP_CO_USER'
      | 'ROLE_OP_CO_CONTRACTOR',
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .removeRole(email, authority, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create or update
   * @param {string} email
   * @param {PersonCommand} personCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonApi
   */
  public update(
    email: string,
    personCommand: PersonCommand,
    options?: AxiosRequestConfig
  ) {
    return PersonApiFp(this.configuration)
      .update(email, personCommand, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * PersonRequestApi - axios parameter creator
 * @export
 */
export const PersonRequestApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequests: async (
      page?: number,
      size?: number,
      sort?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/person-request`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {PersonRequestCommand} personRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPerson: async (
      personRequestCommand: PersonRequestCommand,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'personRequestCommand' is not null or undefined
      assertParamExists(
        'requestPerson',
        'personRequestCommand',
        personRequestCommand
      )
      const localVarPath = `/person-request`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        personRequestCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * PersonRequestApi - functional programming interface
 * @export
 */
export const PersonRequestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PersonRequestApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRequests(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PagedModelPersonRequestSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRequests(
        page,
        size,
        sort,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {PersonRequestCommand} personRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestPerson(
      personRequestCommand: PersonRequestCommand,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PersonRequestSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestPerson(
        personRequestCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * PersonRequestApi - factory interface
 * @export
 */
export const PersonRequestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PersonRequestApiFp(configuration)
  return {
    /**
     *
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequests(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ): AxiosPromise<PagedModelPersonRequestSummary> {
      return localVarFp
        .getRequests(page, size, sort, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {PersonRequestCommand} personRequestCommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPerson(
      personRequestCommand: PersonRequestCommand,
      options?: any
    ): AxiosPromise<PersonRequestSummary> {
      return localVarFp
        .requestPerson(personRequestCommand, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * PersonRequestApi - object-oriented interface
 * @export
 * @class PersonRequestApi
 * @extends {BaseAPI}
 */
export class PersonRequestApi extends BaseAPI {
  /**
   *
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonRequestApi
   */
  public getRequests(
    page?: number,
    size?: number,
    sort?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return PersonRequestApiFp(this.configuration)
      .getRequests(page, size, sort, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {PersonRequestCommand} personRequestCommand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonRequestApi
   */
  public requestPerson(
    personRequestCommand: PersonRequestCommand,
    options?: AxiosRequestConfig
  ) {
    return PersonRequestApiFp(this.configuration)
      .requestPerson(personRequestCommand, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get all available user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/role`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all available user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CollectionModelRole>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RoleApiFp(configuration)
  return {
    /**
     *
     * @summary Get all available user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any): AxiosPromise<CollectionModelRole> {
      return localVarFp
        .getAll(options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
  /**
   *
   * @summary Get all available user roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public getAll(options?: AxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .getAll(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * RootControllerApi - axios parameter creator
 * @export
 */
export const RootControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    root: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * RootControllerApi - functional programming interface
 * @export
 */
export const RootControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RootControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async root(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapStringObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.root(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * RootControllerApi - factory interface
 * @export
 */
export const RootControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RootControllerApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    root(options?: any): AxiosPromise<EntityModelMapStringObject> {
      return localVarFp.root(options).then(request => request(axios, basePath))
    }
  }
}

/**
 * RootControllerApi - object-oriented interface
 * @export
 * @class RootControllerApi
 * @extends {BaseAPI}
 */
export class RootControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RootControllerApi
   */
  public root(options?: AxiosRequestConfig) {
    return RootControllerApiFp(this.configuration)
      .root(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * TestTemplateControllerApi - axios parameter creator
 * @export
 */
export const TestTemplateControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [email]
     * @param {string} [givenName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPersonAdded: async (
      email?: string,
      givenName?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/test-template/email/person-added`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      if (givenName !== undefined) {
        localVarQueryParameter['givenName'] = givenName
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivacyQuestionnaire: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/test-template/attachment/privacy-questionnaire`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTechStack: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/test-template/attachment/tech-stack`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplates: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/public/test-template`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TestTemplateControllerApi - functional programming interface
 * @export
 */
export const TestTemplateControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    TestTemplateControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} [email]
     * @param {string} [givenName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPersonAdded(
      email?: string,
      givenName?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonAdded(
        email,
        givenName,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivacyQuestionnaire(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivacyQuestionnaire(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTechStack(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTechStack(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTemplates(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EntityModelMapObjectObject>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * TestTemplateControllerApi - factory interface
 * @export
 */
export const TestTemplateControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TestTemplateControllerApiFp(configuration)
  return {
    /**
     *
     * @param {string} [email]
     * @param {string} [givenName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPersonAdded(
      email?: string,
      givenName?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getPersonAdded(email, givenName, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivacyQuestionnaire(options?: any): AxiosPromise<string> {
      return localVarFp
        .getPrivacyQuestionnaire(options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTechStack(options?: any): AxiosPromise<string> {
      return localVarFp
        .getTechStack(options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplates(options?: any): AxiosPromise<EntityModelMapObjectObject> {
      return localVarFp
        .getTemplates(options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * TestTemplateControllerApi - object-oriented interface
 * @export
 * @class TestTemplateControllerApi
 * @extends {BaseAPI}
 */
export class TestTemplateControllerApi extends BaseAPI {
  /**
   *
   * @param {string} [email]
   * @param {string} [givenName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestTemplateControllerApi
   */
  public getPersonAdded(
    email?: string,
    givenName?: string,
    options?: AxiosRequestConfig
  ) {
    return TestTemplateControllerApiFp(this.configuration)
      .getPersonAdded(email, givenName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestTemplateControllerApi
   */
  public getPrivacyQuestionnaire(options?: AxiosRequestConfig) {
    return TestTemplateControllerApiFp(this.configuration)
      .getPrivacyQuestionnaire(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestTemplateControllerApi
   */
  public getTechStack(options?: AxiosRequestConfig) {
    return TestTemplateControllerApiFp(this.configuration)
      .getTechStack(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestTemplateControllerApi
   */
  public getTemplates(options?: AxiosRequestConfig) {
    return TestTemplateControllerApiFp(this.configuration)
      .getTemplates(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * UserInfoApi - axios parameter creator
 * @export
 */
export const UserInfoApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/userinfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication GoogleID required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UserInfoApi - functional programming interface
 * @export
 */
export const UserInfoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserInfoApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfo(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserInfoSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * UserInfoApi - factory interface
 * @export
 */
export const UserInfoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserInfoApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo(options?: any): AxiosPromise<UserInfoSummary> {
      return localVarFp
        .getUserInfo(options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * UserInfoApi - object-oriented interface
 * @export
 * @class UserInfoApi
 * @extends {BaseAPI}
 */
export class UserInfoApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInfoApi
   */
  public getUserInfo(options?: AxiosRequestConfig) {
    return UserInfoApiFp(this.configuration)
      .getUserInfo(options)
      .then(request => request(this.axios, this.basePath))
  }
}
